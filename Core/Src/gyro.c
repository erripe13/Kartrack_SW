/*	Made By Adrien
 *
 * Copyright (c) [2020] by InvenSense, Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *	I2C Driver for ICM45605
 */
#include "stm32f7xx_hal.h"

#include "gyro.h"
#include <stdio.h>

// Global variables
extern I2C_HandleTypeDef hi2c1;    // Declare I2C instance (defined in the file generated by STM32CubeMX)

// Function to write to a sensor register
HAL_StatusTypeDef ICM45605_WriteRegister(uint8_t reg, uint8_t data) {
    // Using HAL_I2C_Mem_Write to write to a register
    return HAL_I2C_Mem_Write(&hi2c1, ICM45605_I2C_ADDRESS << 1, reg, I2C_MEMADD_SIZE_8BIT, &data, 1, I2C_TIMEOUT);
}

// Function to read a sensor register
HAL_StatusTypeDef ICM45605_ReadRegister(uint8_t reg, uint8_t *data) {
    // Using HAL_I2C_Mem_Read to read a register
    return HAL_I2C_Mem_Read(&hi2c1, ICM45605_I2C_ADDRESS << 1, reg, I2C_MEMADD_SIZE_8BIT, data, 1, I2C_TIMEOUT);
}

// Function to read multiple consecutive registers
HAL_StatusTypeDef ICM45605_ReadRegisters(uint8_t regStart, uint8_t *buffer, uint8_t length) {
    // Using HAL_I2C_Mem_Read to read multiple consecutive registers
    return HAL_I2C_Mem_Read(&hi2c1, ICM45605_I2C_ADDRESS << 1, regStart, I2C_MEMADD_SIZE_8BIT, buffer, length, I2C_TIMEOUT);
}

// Function to write to an indirect register
HAL_StatusTypeDef ICM45605_WriteIndirect(uint16_t reg, uint8_t data) {
    HAL_StatusTypeDef status;
    
    // Write the register address (16-bit) to the Bank and Register Select registers
    status = ICM45605_WriteRegister(0x7C, (uint8_t)(reg >> 8));    // Bank Select
    if (status != HAL_OK) return status;
    
    status = ICM45605_WriteRegister(0x7D, (uint8_t)(reg & 0xFF));  // Register Select
    if (status != HAL_OK) return status;
    
    // Write the data to the Register Data register
    status = ICM45605_WriteRegister(0x7E, data);                   // Register Data
    
    return status;
}

// Function to initialize the ICM45605 sensor
HAL_StatusTypeDef ICM45605_Init(void) {
    HAL_StatusTypeDef status;
    uint8_t who_am_i = 0;
    
    // Startup delay
    HAL_Delay(100);

    // Read WHO_AM_I register to verify communication
    if (ICM45605_ReadRegister(ICM45605_WHO_AM_I, &who_am_i) != HAL_OK) {
        return HAL_ERROR;
    }
    printf("WHO_AM_I = 0x%02X\r\n", who_am_i);

    // Check if the sensor responds correctly
    if (who_am_i != ICM45605_DEVICE_ID) {
        return HAL_ERROR;
    }

    // Reset the sensor
    if (ICM45605_WriteRegister(ICM45605_REG_PWR_MGMT_1, ICM45605_RESET) != HAL_OK) {
        return HAL_ERROR;
    }
    
    // Wait for reset to complete
    HAL_Delay(100);
    
    // Exit sleep mode
    if (ICM45605_WriteRegister(ICM45605_REG_PWR_MGMT_1, 0x01) != HAL_OK) {
        return HAL_ERROR;
    }
    
    HAL_Delay(10);
    
    // Sensor configuration
    // Accelerometer configuration (±2g by default)
    status = ICM45605_WriteRegister(ICM45605_REG_ACCEL_CONFIG, ICM45605_ACCEL_RANGE_2G);
    if (status != HAL_OK) return status;
    
    // Gyroscope configuration (±250 dps by default)
    status = ICM45605_WriteRegister(ICM45605_REG_GYRO_CONFIG, ICM45605_GYRO_RANGE_250DPS);
    if (status != HAL_OK) return status;
    
    // Sampling frequency configuration (100 Hz by default)
    status = ICM45605_WriteRegister(ICM45605_REG_CONFIG, ICM45605_DLPF_BW_98HZ);
    if (status != HAL_OK) return status;
    
    // Division frequency configuration (100 Hz)
    status = ICM45605_WriteRegister(ICM45605_REG_SMPLRT_DIV, 0x09);
    if (status != HAL_OK) return status;

    return HAL_OK;
}

// Function to configure the IMU for fast operation (6400Hz)
HAL_StatusTypeDef ICM45605_ConfigureFastMode(void) {
    HAL_StatusTypeDef status;
    
    // 1. Enable both Gyro and Accel in Low Noise (LN) mode
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_PWR_CONFIG, ICM45605_PWR_MODE_LN_BOTH);
    if (status != HAL_OK) return status;
    
    // 2. Configure Gyroscope → ±2000dps @ 6400Hz
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_GYRO_CONFIG, ICM45605_GYRO_2000DPS_6400HZ);
    if (status != HAL_OK) return status;
    
    // 3. Configure Accelerometer → ±16g @ 6400Hz
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_ACCEL_CONFIG, ICM45605_ACCEL_16G_6400HZ);
    if (status != HAL_OK) return status;
    
    // 4. Bypass Gyro Low-Pass Filter
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_GYRO_LPF, ICM45605_LPF_BYPASS);
    if (status != HAL_OK) return status;
    
    // 5. Bypass Accelerometer Low-Pass Filter
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_ACCEL_LPF, ICM45605_LPF_BYPASS);
    if (status != HAL_OK) return status;
    
    return HAL_OK;
}

// Function to configure the IMU for high-performance kart tracking
HAL_StatusTypeDef ICM45605_ConfigureKartTrackingMode(void) {
    HAL_StatusTypeDef status;
    
    // Reset the sensor first to ensure clean configuration
    status = ICM45605_WriteRegister(ICM45605_REG_PWR_MGMT_1, ICM45605_RESET);
    if (status != HAL_OK) return status;
    
    // Wait for reset to complete
    HAL_Delay(100);
    
    // Exit sleep mode and select the best clock source
    status = ICM45605_WriteRegister(ICM45605_REG_PWR_MGMT_1, 0x01); // Auto-select best clock
    if (status != HAL_OK) return status;
    
    HAL_Delay(10);
    
    // 1. Enable both Gyro and Accel in Low Noise (LN) mode for maximum precision
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_PWR_CONFIG, ICM45605_PWR_MODE_LN_BOTH);
    if (status != HAL_OK) return status;
    
    // 2. Configure Gyroscope → ±2000dps @ 6400Hz (maximum rate for fast movements)
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_GYRO_CONFIG, ICM45605_GYRO_2000DPS_6400HZ);
    if (status != HAL_OK) return status;
    
    // 3. Configure Accelerometer → ±16g @ 6400Hz (for high acceleration in karts)
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_ACCEL_CONFIG, ICM45605_ACCEL_16G_6400HZ);
    if (status != HAL_OK) return status;
    
    // 4. Bypass Gyro Low-Pass Filter for maximum response speed (may increase noise)
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_GYRO_LPF, ICM45605_LPF_BYPASS);
    if (status != HAL_OK) return status;
    
    // 5. Bypass Accelerometer Low-Pass Filter for fastest response
    status = ICM45605_WriteIndirect(ICM45605_INDIRECT_ACCEL_LPF, ICM45605_LPF_BYPASS);
    if (status != HAL_OK) return status;
    
    // 6. Disable FIFO to minimize latency (direct register reading)
    status = ICM45605_WriteRegister(ICM45605_REG_FIFO_EN, 0x00);
    if (status != HAL_OK) return status;
    
    return HAL_OK;
}

// Function to perform gyroscope calibration (removes bias)
HAL_StatusTypeDef ICM45605_CalibrateGyro(ICM45605_Gyro_t *gyro_offset, uint16_t samples) {
    HAL_StatusTypeDef status;
    ICM45605_Gyro_t gyro;
    int32_t x_sum = 0, y_sum = 0, z_sum = 0;
    uint16_t i;
    
    // Make sure the sensor is stationary during calibration
    
    // Take multiple samples to average out noise
    for (i = 0; i < samples; i++) {
        status = ICM45605_ReadGyro(&gyro);
        if (status != HAL_OK) return status;
        
        x_sum += gyro.x;
        y_sum += gyro.y;
        z_sum += gyro.z;
        
        HAL_Delay(5); // Small delay between samples
    }
    
    // Calculate average offset values
    gyro_offset->x = (int16_t)(x_sum / samples);
    gyro_offset->y = (int16_t)(y_sum / samples);
    gyro_offset->z = (int16_t)(z_sum / samples);
    
    return HAL_OK;
}

// Function to read gyroscope with offset compensation
HAL_StatusTypeDef ICM45605_ReadGyroCompensated(ICM45605_Gyro_t *gyro, const ICM45605_Gyro_t *gyro_offset) {
    HAL_StatusTypeDef status;
    
    status = ICM45605_ReadGyro(gyro);
    if (status != HAL_OK) return status;
    
    // Apply offset compensation
    if (gyro_offset != NULL) {
        gyro->x -= gyro_offset->x;
        gyro->y -= gyro_offset->y;
        gyro->z -= gyro_offset->z;
    }
    
    return HAL_OK;
}

// Function to read both accel and gyro in single burst (reduces I2C overhead)
HAL_StatusTypeDef ICM45605_ReadMotionData(ICM45605_Accel_t *accel, ICM45605_Gyro_t *gyro) {
    uint8_t buffer[14]; // Accel (6) + Temp (2) + Gyro (6)
    HAL_StatusTypeDef status;
    
    // Read all motion data in a single burst starting from ACCEL_XOUT_H
    status = ICM45605_ReadRegisters(ICM45605_REG_ACCEL_XOUT_H, buffer, 14);
    if (status != HAL_OK) return status;
    
    // Parse accelerometer data
    accel->x = (int16_t)(buffer[0] << 8 | buffer[1]);
    accel->y = (int16_t)(buffer[2] << 8 | buffer[3]);
    accel->z = (int16_t)(buffer[4] << 8 | buffer[5]);
    
    // Parse gyroscope data (skipping temperature bytes)
    gyro->x = (int16_t)(buffer[8] << 8 | buffer[9]);
    gyro->y = (int16_t)(buffer[10] << 8 | buffer[11]);
    gyro->z = (int16_t)(buffer[12] << 8 | buffer[13]);
    
    return HAL_OK;
}

// Function to read accelerometer data
HAL_StatusTypeDef ICM45605_ReadAccel(ICM45605_Accel_t *accel) {
    uint8_t buffer[6];
    HAL_StatusTypeDef status;
    
    status = ICM45605_ReadRegisters(ICM45605_REG_ACCEL_XOUT_H, buffer, 6);
    if (status != HAL_OK) return status;
    
    // Convert to signed 16-bit values
    accel->x = (int16_t)(buffer[0] << 8 | buffer[1]);
    accel->y = (int16_t)(buffer[2] << 8 | buffer[3]);
    accel->z = (int16_t)(buffer[4] << 8 | buffer[5]);
    
    return HAL_OK;
}

// Function to read gyroscope data
HAL_StatusTypeDef ICM45605_ReadGyro(ICM45605_Gyro_t *gyro) {
    uint8_t buffer[6];
    HAL_StatusTypeDef status;
    
    status = ICM45605_ReadRegisters(ICM45605_REG_GYRO_XOUT_H, buffer, 6);
    if (status != HAL_OK) return status;
    
    // Convert to signed 16-bit values
    gyro->x = (int16_t)(buffer[0] << 8 | buffer[1]);
    gyro->y = (int16_t)(buffer[2] << 8 | buffer[3]);
    gyro->z = (int16_t)(buffer[4] << 8 | buffer[5]);
    
    return HAL_OK;
}

// Function to read temperature
HAL_StatusTypeDef ICM45605_ReadTemp(float *temp) {
    uint8_t buffer[2];
    int16_t raw_temp;
    HAL_StatusTypeDef status;
    
    status = ICM45605_ReadRegisters(ICM45605_REG_TEMP_OUT_H, buffer, 2);
    if (status != HAL_OK) return status;
    
    raw_temp = (int16_t)(buffer[0] << 8 | buffer[1]);
    // Conversion formula according to the datasheet
    *temp = ((float)raw_temp / 327.68f) + 21.0f;
    
    return HAL_OK;
}

// Function to configure the accelerometer scale
HAL_StatusTypeDef ICM45605_SetAccelRange(uint8_t range) {
    if (range > ICM45605_ACCEL_RANGE_16G) return HAL_ERROR;
    
    return ICM45605_WriteRegister(ICM45605_REG_ACCEL_CONFIG, range);
}

// Function to configure the gyroscope scale
HAL_StatusTypeDef ICM45605_SetGyroRange(uint8_t range) {
    if (range > ICM45605_GYRO_RANGE_2000DPS) return HAL_ERROR;
    
    return ICM45605_WriteRegister(ICM45605_REG_GYRO_CONFIG, range);
}

// Usage example
void ICM45605_Test(void) {
    ICM45605_Accel_t accel;
    ICM45605_Gyro_t gyro;
    float temp;
    
    if (ICM45605_Init() == HAL_OK) {
        // Read accelerometer, gyroscope and temperature data
        if (ICM45605_ReadAccel(&accel) == HAL_OK && 
            ICM45605_ReadGyro(&gyro) == HAL_OK &&
            ICM45605_ReadTemp(&temp) == HAL_OK) {
            
            // At this point, you can use the accel, gyro and temp data
            // For example, transmit via UART, display on an LCD screen, etc.
        }
    } else {
        // Handle initialization error
    }
}



